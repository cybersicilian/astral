import Card from "../cards/Card";
import Deck from "../deck/Deck";
import { CardArgs } from "../cards/CardArgs";
import { Rarity } from "../../structure/utils/CardEnums";
import Upgrade from "./systems/Upgrade";
import { IIdentifiable } from "../../structure/interfaces/IIdentifiable";
import { ChoiceType } from "../cards/choices/ChoiceType";
import { IProppable, Properties } from "../../structure/interfaces/IProppable";
import { IEventable } from "../../structure/interfaces/IEventable";
import { VosEvent } from "../../structure/utils/Generics";
import { AbilityChoices } from "../cards/choices/AbilityChoices";
export type CardState = {
    name: string;
    text: string;
    props: {
        [key: string]: string | number | boolean | object;
    };
    power: number;
    rarity: Rarity;
    formula?: string[];
    playable?: boolean;
};
export type PlayerState = {
    name: string;
    cards: number;
    handsize: number;
    skipped: number;
    props: {
        [key: string]: string | number | boolean | object;
    };
    turnsRemaining: number;
    canWin: boolean;
    you: boolean;
    host: boolean;
    order: number;
    winReason: string;
};
export default class Player implements IIdentifiable, IProppable, IEventable {
    private name;
    private cards;
    private skipped;
    private props;
    private events;
    private turnPlacement;
    private turnsRemaining;
    private canWin;
    private winReason;
    private handSize;
    private bot;
    private host;
    private botProfile?;
    private eventList;
    constructor(cards: number, deck: Deck);
    addResource(key: string, amt: number): void;
    upgrades(): Upgrade[];
    addUpgrade(u: Upgrade): void;
    setHost(host?: boolean): this;
    isHost(): boolean;
    getResources(): {
        [key: string]: any;
    };
    getUIs(): {
        marketplace: any;
        gene_bank: any;
        casino: any;
        upgrade: boolean;
    };
    getRelevantProps(): {
        [key: string]: any;
    };
    getPrivate(you?: boolean): PlayerState;
    getCards(opps: Player[], deck: Deck): CardState[];
    setBot(): this;
    isBot(): boolean;
    setName(name: string): this;
    getCardStats(): {
        [key: string]: {
            drawn: number;
            played: number;
            discarded: number;
            given: number;
            text: string;
        };
    };
    setTurnPlacement(turnPlacement: number): this;
    getTurnPlacement(): number;
    getHandsize(): number;
    addHandsize(mod: number): this;
    setHandsize(mod: number): this;
    propList(): Properties;
    on(name: string, func: (VosEvent: any) => void): this;
    addEvent(name: string, func: (cardArgs: CardArgs) => void): void;
    getWinReason(): string;
    fireEvents(name: string, cardArgs: CardArgs): void;
    addTurns(mod: number): this;
    setTurns(mod: number): this;
    getTurns(): number;
    rollDice(): any;
    setCanWin(check: boolean, reason?: string): this;
    winCheck(): boolean;
    setProp(key: string, value: any, cardArgs?: CardArgs): this;
    getProps(): Properties;
    getProp(key: string): any;
    skip(): void;
    skipCheck(): boolean;
    toPlayerState(): PlayerState;
    getLogText(): string;
    getName(): string;
    cih(): Card[];
    setCiH(cards: Card[]): this;
    inHand(): number;
    turnStart(cardArgs: CardArgs): void;
    draw(deck: Deck, qty?: number): void;
    play(card: Card, opps: Player[], deck: Deck, choices?: (ChoiceType)[][]): void;
    give(card: Card, player: Player): void;
    discard(card: Card, deck: Deck): void;
    discardRandom(cardArgs: CardArgs): void;
    discardChoose(cardArgs: CardArgs): void;
    randomCard(): Card;
    weightedDiscard(cardArgs: CardArgs): Card | null;
    weightedDiscardToHand(cardArgs: CardArgs): void;
    weightedGive(cardArgs: CardArgs): Card | null;
    weightedPlay(cardArgs: CardArgs): Card | null;
    getEvent(name: string): VosEvent[];
    removeEvent(name: string): this;
    selectChoices(choices: AbilityChoices[], cardArgs: CardArgs): ChoiceType[];
    evaluate(card: Card, args: CardArgs): number;
}
